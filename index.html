<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Overcooked+ — Orders 2.0 + Collision + Sprites + FX</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
  :root{--bg:#1e1f26;--ink:#eef0f6;--muted:#b7b9c6}
  html,body{margin:0;height:100%;background:var(--bg);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #wrap{max-width:100vw;margin:10px auto;padding:0 12px}
  canvas{display:block;background:#2b2d3a;margin:0 auto;border:4px solid #fff;border-radius:12px;box-shadow:0 10px 28px rgba(0,0,0,.35);touch-action:none;user-select:none}
  #ui{text-align:center;color:var(--muted);margin:10px 0 0;font-size:14px}
  kbd{background:#3a3c49;color:#fff;padding:2px 6px;border-radius:6px;border:1px solid #4b4d5d}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game" width="960" height="600"></canvas>
  <div id="ui">Move: <kbd>W/A/S/D</kbd> or Arrows · Interact/Hold: <kbd>Space</kbd>/<kbd>E</kbd> · Mouse/Touch: tap stations, drag left for joystick, tap right ACTION · Pause: <kbd>P</kbd> · Restart: <kbd>R</kbd></div>
</div>
<script>
(() => {
  // ===== Canvas & utils =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // === Responsive scaling (letterboxed) ===
  const BASE_W = 960, BASE_H = 600, ASPECT = BASE_W/BASE_H;
  function fitCanvas(){
    // Reserve a bit of vertical space for UI text under the canvas
    const uiReserve = 90;
    const vw = Math.max(320, window.innerWidth);
    const vh = Math.max(320, window.innerHeight - uiReserve);
    const scale = Math.min(vw/BASE_W, vh/BASE_H);
    const cssW = Math.round(BASE_W * scale);
    const cssH = Math.round(BASE_H * scale);
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
  }
  window.addEventListener('resize', fitCanvas);
  window.addEventListener('orientationchange', fitCanvas);
  // first fit immediately after script loads
  fitCanvas();
  const TILE=64, GRID_W=12, GRID_H=8;
  const origin=()=>({ox:(canvas.width-GRID_W*TILE)/2, oy:(canvas.height-GRID_H*TILE)/2 + TILE*0.2});
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const now=()=>performance.now();
  let SHAKE=0;

  function rr(x,y,w,h,r,fill,stroke){
    ctx.save(); const rad=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rad,y);
    ctx.arcTo(x+w,y,x+w,y+h,rad);
    ctx.arcTo(x+w,y+h,x,y+h,rad);
    ctx.arcTo(x,y+h,x,y,rad);
    ctx.arcTo(x,y,x+w,y,rad);
    ctx.closePath();
    if(fill){ctx.fillStyle=fill;ctx.fill();}
    if(stroke){ctx.lineWidth=2;ctx.strokeStyle=stroke;ctx.stroke();}
    ctx.restore();
  }
  function text(str,x,y,size=16,color="#eef0f6",align='left'){
    ctx.save(); ctx.fillStyle=color; ctx.font=`700 ${size}px ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial`;
    ctx.textAlign=align; ctx.textBaseline='top'; ctx.fillText(str,x,y); ctx.restore();
  }
  function bar(x,y,w,h,ratio,bg="#3a3c49",fg="#79e08a"){
    rr(x,y,w,h,h/2,bg); rr(x+2,y+2,(w-4)*clamp(ratio,0,1),h-4,(h-4)/2,fg);
  }
  function rand(a,b){ return Math.random()*(b-a)+a; }

  // ===== Item Sprites (procedural drawings) =====
  function drawCircle(x,y,r,fill,stroke){ ctx.save(); ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); if(fill){ctx.fillStyle=fill; ctx.fill();} if(stroke){ctx.lineWidth=2; ctx.strokeStyle=stroke; ctx.stroke();} ctx.restore(); }
  function drawRect(x,y,w,h,fill,stroke){ ctx.save(); if(fill){ctx.fillStyle=fill; ctx.fillRect(x,y,w,h);} if(stroke){ctx.strokeStyle=stroke; ctx.lineWidth=2; ctx.strokeRect(x,y,w,h);} ctx.restore(); }
  const SPR = {
    plateBase(x,y,s=1){ drawCircle(x,y,18*s,'#f5f7fb','#d8dbe6'); drawCircle(x,y,14*s,'#ffffff','#e6e9f3'); },
    bunTop(x,y,s=1){ drawCircle(x,y,10*s,'#e9c07f','#cfaa6f'); },
    bunBottom(x,y,s=1){ drawCircle(x,y,10*s,'#e1b673','#c9a064'); },
    patty(x,y,s=1){ drawRect(x-12*s,y-6*s,24*s,12*s,'#5a3a2a','#442a1d'); },
    lettuceWhole(x,y,s=1){ drawCircle(x,y,10*s,'#67d27a','#3cae53'); },
    lettuceChopped(x,y,s=1){ for(let i=0;i<5;i++) drawRect(x-12*s+i*5*s,y-5*s,4*s,10*s,'#6ddc80'); },
    tomatoWhole(x,y,s=1){ drawCircle(x,y,10*s,'#ff5a60','#cc4348'); drawCircle(x,y,3*s,'#ffffff22'); },
    tomatoChopped(x,y,s=1){ for(let i=0;i<3;i++) drawCircle(x-8*s+i*8*s,y,4*s,'#ff6e74','#cc4348'); },
    meatRaw(x,y,s=1){ drawRect(x-12*s,y-6*s,24*s,12*s,'#c94a4a','#9c3838'); },
    meatCooked(x,y,s=1){ drawRect(x-12*s,y-6*s,24*s,12*s,'#6b3f2a','#4a2b1c'); },
  };
  function drawItemSprite(itemOrName, x, y, scale=1){
    const name = typeof itemOrName === 'string' ? itemOrName : niceName(itemOrName);
    ctx.save();
    if (name.startsWith('Plate')){
      SPR.plateBase(x,y,scale);
      const contents = (typeof itemOrName==='object' && itemOrName && itemOrName.kind==='Plate') ? itemOrName.contents : [];
      const hasBun = contents.includes('Bun');
      const hasPatty = contents.includes('Cooked Patty');
      const hasLettuce = contents.includes('Chopped Lettuce');
      const hasTomato = contents.includes('Chopped Tomato');
      const y0 = y + 10*scale;
      if (hasBun)      SPR.bunBottom(x, y0, 0.95*scale);
      if (hasPatty)    SPR.patty(x, y0 - 8*scale, 0.95*scale);
      if (hasLettuce)  SPR.lettuceChopped(x, y0 - 14*scale, 0.9*scale);
      if (hasTomato)   SPR.tomatoChopped(x, y0 - 19*scale, 0.9*scale);
      if (hasBun && hasPatty) SPR.bunTop(x, y0 - 26*scale, 0.95*scale);
      ctx.restore(); return;
    }
    switch(name){
      case 'Bun': SPR.bunTop(x,y-3*scale,1*scale); SPR.bunBottom(x,y+7*scale,1*scale); break;
      case 'Raw Meat': SPR.meatRaw(x,y,1*scale); break;
      case 'Cooked Patty': SPR.meatCooked(x,y,1*scale); break;
      case 'Burned Patty': SPR.meatCooked(x,y,1*scale); drawRect(x-14*scale,y-8*scale,28*scale,16*scale,null,'#000'); break;
      case 'Tomato': SPR.tomatoWhole(x,y,1*scale); break;
      case 'Chopped Tomato': SPR.tomatoChopped(x,y,1*scale); break;
      case 'Lettuce': SPR.lettuceWhole(x,y,1*scale); break;
      case 'Chopped Lettuce': SPR.lettuceChopped(x,y,1*scale); break;
      default: SPR.plateBase(x,y,scale*0.9);
    }
    ctx.restore();
  }

  // ===== Round / Stars config =====
  const ROUND_TOTAL_MS = 3 * 60 * 1000; // 3 minutes
  const STAR_1 = 100, STAR_2 = 200, STAR_3 = 300; // coins thresholds

  // ===== Orders 2.0 Tuning =====
  const TUNING = {
    ORDER_INTERVAL_BASE: 30000,
    ORDER_RUSH_INTERVAL: 18000,
    ORDER_TTL: 60000,
    COMBO_WINDOW_MS: 8000,
    BASE_VALUES: { 'Burger': 40, 'Burger + Lettuce': 50, 'Burger + Tomato': 50, 'Deluxe Burger': 65 },
    MISS_PENALTY: 10
  };
  let combo = 0, lastServeAt = 0;

  // ===== Input & player =====
  const keys={}; let paused=false;
  const INTERACT_KEYS = new Set([' ','e','E']);

  const PICKUP_RADIUS = 90;
  const MAGNET_RADIUS = 150;
  const MAGNET_PULL_PX_PER_SEC = 260;
  const MAGNET_SNAP_DIST = 18;
  const MAGNET_MAX_TIME_MS = 120;

  const player={
    x:TILE*2,y:TILE*5,w:36,h:36,speed:230,
    carrying:null, action:null, _holding:false,
    _magnetTarget:null, _magnetUntil:0
  };

  // Put joystick early so render can see it
  const joystick = { active:false, id:null, baseX:0, baseY:0, curX:0, curY:0, vecX:0, vecY:0, maxR:56 };

  addEventListener('keydown',e=>{
    if(e.repeat) return;
    keys[e.key]=true;
    if(e.key==='p'||e.key==='P') paused=!paused;
    if(e.key==='r'||e.key==='R'){ reset(); }
    if(INTERACT_KEYS.has(e.key)){
      if(roundState==='running'){
        player._holding=true;
        const target = getNearestActionableStation(true);
        if(target){ tryStartMagnet(target); interactStart(target); }
      }
    }
  });
  addEventListener('keyup',e=>{
    keys[e.key]=false;
    if(INTERACT_KEYS.has(e.key)){ player._holding=false; player._magnetTarget=null; player._magnetUntil=0; }
  });

  // ===== Items =====
  const Item={
    tomato:()=>({kind:'Tomato',chopped:false}),
    lettuce:()=>({kind:'Lettuce',chopped:false}),
    meat:()=>({kind:'Meat',cooked:false,burned:false}),
    bun:()=>({kind:'Bun'}),
    plate:(c=[])=>({kind:'Plate',contents:[...c]}),
  };
  const niceName=it=>{
    if(!it) return '';
    if(it.kind==='Plate') return it.contents.length?`Plate(${it.contents.join(' + ')})`:'Plate';
    if(it.kind==='Tomato'&&it.chopped) return 'Chopped Tomato';
    if(it.kind==='Lettuce'&&it.chopped) return 'Chopped Lettuce';
    if(it.kind==='Meat'&&it.burned)  return 'Burned Patty';
    if(it.kind==='Meat'&&it.cooked)  return 'Cooked Patty';
    if(it.kind==='Meat'&&!it.cooked) return 'Raw Meat';
    return it.kind;
  };

  // ===== Stations (+ 5-slot counter) =====
  const stations=[
    {type:'crateTomato', x:TILE*1, y:TILE*1},
    {type:'crateLettuce',x:TILE*2, y:TILE*1},
    {type:'crateMeat',   x:TILE*3, y:TILE*1},
    {type:'crateBun',    x:TILE*4, y:TILE*1},
    {type:'board',       x:TILE*6, y:TILE*1, holding:null, progress:0},
    {type:'stove',       x:TILE*8, y:TILE*1, pan:null},
    {type:'plate',       x:TILE*10,y:TILE*1, plate:null},
    {type:'counter',     x:TILE*3, y:TILE*3, slots:[null,null,null,null,null]},
    {type:'dropoff',     x:TILE*10,y:TILE*6},
    {type:'trash',       x:TILE*1, y:TILE*6},
  ];
  const stationCenter = (s)=>({cx:s.x+TILE/2, cy:s.y+TILE/2});
  const playerCenter = ()=>({px:player.x+player.w/2, py:player.y+player.h/2});
  const dist2 = (x1,y1,x2,y2)=> (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);

  // ===== Collision map derived from stations =====
  const solids = new Array(GRID_W*GRID_H).fill(0);
  function setSolid(gx,gy){ if(gx>=0&&gy>=0&&gx<GRID_W&&gy<GRID_H) solids[gy*GRID_W+gx]=1; }
  function rebuildSolids(){
    solids.fill(0);
    for(const s of stations){
      if(s.type==='counter'){
        const gx = Math.round(s.x/TILE), gy = Math.round(s.y/TILE);
        for(let i=0;i<5;i++) setSolid(gx+i,gy);
        continue;
      }
      if (s.type==='dropoff') continue; // drop-off non-solid
      const gx = Math.round(s.x/TILE), gy = Math.round(s.y/TILE);
      setSolid(gx,gy);
    }
  }
  rebuildSolids();
  const solidAt = (gx,gy)=>{
    if (gx<0||gy<0||gx>=GRID_W||gy>=GRID_H) return true;
    return solids[gy*GRID_W+gx]===1;
  };

  // ===== Orders (top bubbles, timers) =====
  const orders=[];
  let orderTimer=0, coins=0, score=0;

  const burgerVariants = [
    {label:'Burger',         need:['Bun','Cooked Patty']},
    {label:'Burger + Lettuce',need:['Bun','Cooked Patty','Chopped Lettuce']},
    {label:'Burger + Tomato', need:['Bun','Cooked Patty','Chopped Tomato']},
    {label:'Deluxe Burger',   need:['Bun','Cooked Patty','Chopped Lettuce','Chopped Tomato']},
  ];
  function spawnOrder(){
    if(roundState!=='running') return;
    const v = burgerVariants[Math.floor(Math.random()*burgerVariants.length)];
    orders.unshift({
      id:Math.random().toString(36).slice(2,7),
      name:v.label, need:[...v.need], ttl:TUNING.ORDER_TTL,
      base: TUNING.BASE_VALUES[v.label] || 50
    });
  }

  // ===== Matching & plate helpers =====
  const canonical = (arr)=>[...arr].sort();
  const setEq = (a,b)=> a.length===b.length && canonical(a).every((v,i)=>v===canonical(b)[i]);
  const plateContentsNames = (plate)=>plate.contents.slice();
  function combinePlateAdd(plate,itemName){
    if(plate.contents.includes(itemName)) return false;
    if(['Chopped Tomato','Chopped Lettuce','Cooked Patty','Bun'].includes(itemName)){
      plate.contents.push(itemName); return true;
    }
    return false;
  }
  const carryingPlate=()=> player.carrying && player.carrying.kind==='Plate';

  // ===== Counter slots as virtual stations =====
  function* enumerateStationsWithCounterSlots(){
    for(const s of stations){
      if(s.type!=='counter'){ yield s; continue; }
      for(let i=0;i<s.slots.length;i++){
        const slotX = s.x + i*TILE;
        yield {type:'counterSlot', parent:s, i, x:slotX, y:s.y};
      }
    }
  }

  // ===== Round state =====
  let roundState = 'running';
  let roundMsLeft = ROUND_TOTAL_MS;
  let stars = 0;

  // ===== Animations =====
  const anims = [];
  function spawnAnim(type,x,y){ anims.push({type,x,y,t:0}); }
  function updateAnims(dtMs){ for(const a of anims){ a.t += dtMs; } for(let i=anims.length-1;i>=0;i--){ if(anims[i].t>800) anims.splice(i,1); } }
  function drawAnims(){
    for(const a of anims){
      switch(a.type){
        case 'steam': {
          const p = Math.min(a.t/800,1);
          for(let i=0;i<3;i++){
            const off = i*6; const size = 10 + p*12 - i*2; const up = p*(22+off*0.6);
            ctx.save(); ctx.globalAlpha = (1-p)*(0.9 - i*0.2);
            ctx.fillStyle = '#ffffffcc';
            ctx.beginPath(); ctx.arc(a.x + i*4 -4, a.y - up, size, 0, Math.PI*2); ctx.fill();
            ctx.restore();
          }
          break;
        }
        case 'chop': {
          const p = Math.min(a.t/300,1);
          ctx.save(); ctx.globalAlpha = 1-p; ctx.strokeStyle = '#ffd166'; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.moveTo(a.x-10,a.y-10); ctx.lineTo(a.x+10,a.y+10); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(a.x+10,a.y-10); ctx.lineTo(a.x-10,a.y+10); ctx.stroke();
          ctx.restore();
          break;
        }
        case 'poof': {
          const p = Math.min(a.t/500,1);
          ctx.save(); ctx.globalAlpha = 0.8*(1-p);
          drawCircle(a.x, a.y - 6*p, 8 + 14*p, '#e9eef5');
          ctx.restore();
          break;
        }
      }
    }
  }

  // ===== Interaction rules =====
  function canInteract(base){
    if(roundState!=='running') return false;
    const held = player.carrying;
    const heldName = niceName(held);

    if(base.type==='counterSlot'){
      const s = base.parent, i = base.i, item = s.slots[i], hasItem=!!item;
      if(!hasItem && held) return true;
      if(hasItem && !held) return true;
      if(hasItem && held && item.kind==='Plate') return ['Chopped Tomato','Chopped Lettuce','Cooked Patty','Bun'].includes(heldName);
      if(hasItem && carryingPlate()){
        const comp = niceName(item);
        return ['Chopped Tomato','Chopped Lettuce','Cooked Patty','Bun'].includes(comp);
      }
      return false;
    }

    switch(base.type){
      case 'crateTomato':
      case 'crateLettuce':
      case 'crateMeat':
      case 'crateBun':
        if(base.type==='crateBun' && carryingPlate()) return true;
        return !held;
      case 'plate':
        if(!held && !base.plate) return true;
        if(!held && base.plate)  return true;
        if(held && base.plate)   return ['Chopped Tomato','Chopped Lettuce','Cooked Patty','Bun'].includes(heldName);
        return false;
      case 'board':
        if(!base.holding && held && (held.kind==='Tomato'||held.kind==='Lettuce') && !held.chopped) return true;
        if(base.holding && base.holding.chopped){ if(carryingPlate()) return true; if(!held) return true; }
        return false;
      case 'stove':
        if(!base.pan) base.pan={state:'idle',t:0,item:null};
        if(heldName==='Raw Meat' && base.pan.state==='idle') return true;
        if(!held && (base.pan.state==='cooked'||base.pan.state==='burned')) return true;
        if(carryingPlate() && base.pan.state==='cooked') return true;
        return false;
      case 'dropoff':
        if(!held || held.kind!=='Plate' || !held.contents.length) return false;
        return orders.some(o => setEq(plateContentsNames(held), o.need));
      case 'trash':
        return !!held;
      default: return false;
    }
  }

  function getNearestActionableStation(allowMagnet=false){
    const {px,py}=playerCenter();
    const maxD2 = (allowMagnet? (MAGNET_RADIUS) : PICKUP_RADIUS) ** 2;
    let best=null, bestD2=maxD2;
    for(const s of enumerateStationsWithCounterSlots()){
      const {cx,cy} = (s.type==='counterSlot') ? {cx:s.x+TILE/2, cy:s.y+TILE/2} : stationCenter(s);
      const d2=dist2(px,py,cx,cy);
      if(d2<=bestD2 && canInteract(s)){ best=s; bestD2=d2; }
    }
    return best;
  }

  function getActionableAtScreen(x,y){
    const {ox,oy}=origin();
    const worldX = x - ox, worldY = y - oy;
    let best=null, bestD2= (TILE*0.7)*(TILE*0.7);
    for(const s of enumerateStationsWithCounterSlots()){
      const sx = s.x + TILE/2, sy = s.y + TILE/2;
      const d2 = dist2(worldX,worldY,sx,sy);
      if(d2<=bestD2 && canInteract(s)){ best=s; bestD2=d2; }
    }
    return best;
  }

  // ===== Popups =====
  const popups=[]; const POP_POOL=[];
  function spawnPopup(x,y,txt,color="#79e08a"){
    const p = POP_POOL.pop() || {};
    p.x=x; p.y=y; p.t0=now(); p.dur=700; p.txt=txt; p.color=color;
    popups.push(p);
  }

  // ===== Magnet assist =====
  function tryStartMagnet(target){
    if(!target) return;
    player._magnetTarget = target;
    player._magnetUntil = now() + MAGNET_MAX_TIME_MS;
  }
  function applyMagnet(dt){
    if(!player._magnetTarget) return;
    const timeOK = now() <= player._magnetUntil || player._holding;
    if(!timeOK){ player._magnetTarget=null; return; }
    const {px,py}=playerCenter();
    const {cx,cy} = (player._magnetTarget.type==='counterSlot')
      ? {cx:player._magnetTarget.x+TILE/2, cy:player._magnetTarget.y+TILE/2}
      : stationCenter(player._magnetTarget);
    const dx = cx - px, dy = cy - py;
    const dist = Math.hypot(dx,dy);
    if(dist <= MAGNET_SNAP_DIST){ player._magnetTarget=null; return; }
    const step = MAGNET_PULL_PX_PER_SEC * dt;
    const ux = dx / (dist||1), uy = dy / (dist||1);
    tryMove(ux, uy, dt, step/MAGNET_PULL_PX_PER_SEC);
  }

  // ===== Movement with collision =====
  function tryMove(dx, dy, dt, scale=1){
    let nx = player.x + dx * player.speed * dt * scale;
    let ny = player.y + dy * player.speed * dt * scale;
    const w = player.w, h = player.h;
    const test = (x,y) => solidAt(Math.floor(x/TILE), Math.floor(y/TILE));

    if (dx !== 0) {
      const left = nx, right = nx + w, top = player.y+2, bottom = player.y + h-2;
      if (dx > 0 && (test(right,top)||test(right,bottom))) nx = Math.floor((right)/TILE)*TILE - w - 0.1;
      if (dx < 0 && (test(left,top)||test(left,bottom)))  nx = Math.floor((left)/TILE + 1)*TILE + 0.1;
    }
    player.x = clamp(nx, 0, GRID_W*TILE - w);

    if (dy !== 0) {
      const left = player.x+2, right = player.x + w-2, top = ny, bottom = ny + h;
      if (dy > 0 && (test(left,bottom)||test(right,bottom))) ny = Math.floor((bottom)/TILE)*TILE - h - 0.1;
      if (dy < 0 && (test(left,top)||test(right,top)))      ny = Math.floor((top)/TILE + 1)*TILE + 0.1;
    }
    player.y = clamp(ny, 0, GRID_H*TILE - h);
  }

  // ===== Interactions =====
  function interactStart(preselected=null){
    if(roundState!=='running') return;
    const target = preselected || getNearestActionableStation(false);
    if(!target) return;

    if(target.type==='counterSlot'){
      const c = target.parent, i = target.i, slotItem = c.slots[i];
      if(!slotItem && player.carrying){ c.slots[i] = player.carrying; player.carrying = null; return; }
      if(slotItem && !player.carrying){ player.carrying = slotItem; c.slots[i] = null; return; }
      if(slotItem && player.carrying){
        if(slotItem.kind==='Plate'){
          const added = combinePlateAdd(slotItem, niceName(player.carrying));
          if(added) player.carrying = null;
        } else if (carryingPlate()){
          const comp = niceName(slotItem);
          if(['Chopped Tomato','Chopped Lettuce','Cooked Patty','Bun'].includes(comp)){
            const added = combinePlateAdd(player.carrying, comp);
            if(added) { c.slots[i] = null; spawnAnim('poof', target.x + TILE/2 + origin().ox, target.y + TILE/2 + origin().oy); }
          }
        }
        return;
      }
      return;
    }

    switch(target.type){
      case 'crateTomato': if(!player.carrying) player.carrying = Item.tomato(); break;
      case 'crateLettuce':if(!player.carrying) player.carrying = Item.lettuce(); break;
      case 'crateMeat':   if(!player.carrying) player.carrying = Item.meat();   break;
      case 'crateBun':
        if(carryingPlate()){ combinePlateAdd(player.carrying, 'Bun'); }
        else if(!player.carrying){ player.carrying = Item.bun(); }
        break;
      case 'plate':
        if(!player.carrying && !target.plate){ target.plate = Item.plate(); break; }
        if(!player.carrying && target.plate){ player.carrying = target.plate; target.plate=null; break; }
        if(player.carrying && target.plate){
          const name = niceName(player.carrying);
          if(combinePlateAdd(target.plate, name)){ player.carrying = null; }
        }
        break;
      case 'board':
        if(!target.holding && player.carrying && (player.carrying.kind==='Tomato'||player.carrying.kind==='Lettuce') && !player.carrying.chopped){
          target.holding=player.carrying; player.carrying=null; target.progress=0; target.chopT=0; target.need=1200; target.chopActive=true;
        } else if(target.holding && target.holding.chopped){
          if(carryingPlate()){
            const added = combinePlateAdd(player.carrying, niceName(target.holding));
            if(added){ target.holding=null; target.progress=0; target.chopActive=false; }
          } else if(!player.carrying){
            player.carrying=target.holding; target.holding=null; target.progress=0; target.chopActive=false;
          }
        }
        break;
      case 'stove':
        if(!target.pan) target.pan={state:'idle',t:0,item:null};
        const held=niceName(player.carrying);
        if(player.carrying && held==='Raw Meat' && target.pan.state==='idle'){ target.pan.state='cooking'; target.pan.t=0; target.pan.item=Item.meat(); player.carrying=null; }
        else if(carryingPlate() && target.pan.state==='cooked'){ if(combinePlateAdd(player.carrying, 'Cooked Patty')) target.pan={state:'idle',t:0,item:null}; }
        else if(!player.carrying && target.pan.state==='cooked'){ if(target.pan.item){target.pan.item.cooked=true; target.pan.item.burned=false;} player.carrying=target.pan.item; target.pan={state:'idle',t:0,item:null}; }
        else if(!player.carrying && target.pan.state==='burned'){ if(target.pan.item){target.pan.item.cooked=false; target.pan.item.burned=true;} player.carrying=target.pan.item; target.pan={state:'idle',t:0,item:null}; }
        break;
      case 'dropoff': {
        const plate = player.carrying;
        const contents = plateContentsNames(plate);
        const idx = orders.findIndex(o => setEq(contents, o.need));
        if(idx>-1){
          const o = orders[idx];
          const patience = clamp(o.ttl / TUNING.ORDER_TTL, 0, 1);
          const tnow = now();
          combo = (tnow - lastServeAt <= TUNING.COMBO_WINDOW_MS) ? combo+1 : 1;
          lastServeAt = tnow;
          const payout = Math.round(o.base * (0.4 + 0.6*patience) * (1 + (combo-1)*0.15));
          const {ox,oy}=origin();
          spawnPopup(target.x+ox+TILE/2, target.y+oy+TILE/2, `+${payout}${combo>1?' x'+combo:''}`);
          coins += payout; score += payout; SHAKE = 6;
          orders.splice(idx,1);
          // Steam poof at pass
          spawnAnim('steam', target.x+ox+TILE/2, target.y+oy+TILE/2 - 10);
          player.carrying=null;
        }
        break; }
      case 'trash':
        if (player.carrying){ const {ox,oy}=origin(); spawnAnim('poof', player.x+ox+player.w/2, player.y+oy); }
        player.carrying=null; break;
    }
  }

  // ===== Rendering =====
  function drawStationSprite(type,x,y){
    const icon = {
      crateTomato:'🍅', crateLettuce:'🥬', crateMeat:'🥩', crateBun:'🥯',
      board:'🔪', stove:'🍳', plate:'🍽️', dropoff:'✅', trash:'🗑️'
    }[type] || '⬜';
    rr(x,y,TILE,TILE,12,'#454962');
    const top = type==='board' ? '#d9a76a' :
                type==='stove' ? '#5e657f' :
                type==='plate' ? '#9ad1ff' :
                type==='dropoff' ? '#79e08a' :
                type==='trash' ? '#ff5a6b' :
                '#bbbfd6';
    rr(x+6,y+6,TILE-12,TILE-20,10, top);
    ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font='28px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif';
    ctx.fillText(icon, x+TILE/2, y+TILE/2); ctx.restore();
    const label = {crateTomato:'Tomato', crateLettuce:'Lettuce', crateMeat:'Meat', crateBun:'Bun', board:'Board', stove:'Stove', plate:'Plates', dropoff:'Pass', trash:'Trash'}[type];
    if(label){ ctx.fillStyle='#232430'; ctx.font='700 12px Segoe UI,Arial'; ctx.textAlign='center'; ctx.fillText(label, x+TILE/2, y+TILE-12); }
  }
  function drawCounter(counter){
    const {ox,oy}=origin();
    for(let i=0;i<counter.slots.length;i++){
      const x = counter.x + i*TILE, y = counter.y;
      rr(x+ox, y+oy, TILE, TILE, 12, '#454962');
      rr(x+6+ox, y+6+oy, TILE-12, TILE-20, 10, '#bbbfd6');
      const item = counter.slots[i];
      if(item){ drawItemSprite(item, x+ox+TILE/2, y+oy+TILE/2, 1); }
    }
    const midX = counter.x + (counter.slots.length*TILE)/2;
    ctx.fillStyle='#232430'; ctx.font='700 12px Segoe UI,Arial'; ctx.textAlign='center';
    ctx.fillText('Counter', midX+ox, counter.y+oy+TILE-12);
  }
  function drawStations(){
    const {ox,oy}=origin();
    const target = getNearestActionableStation(true);
    for(const s of stations){ if(s.type==='counter') continue; drawStationSprite(s.type, s.x+ox, s.y+oy); }
    const counter = stations.find(s=>s.type==='counter'); drawCounter(counter);
    if(target){
      const tx = target.x + ox, ty = target.y + oy;
      ctx.save(); ctx.strokeStyle="#79e08a"; ctx.lineWidth=3; ctx.setLineDash([6,6]); ctx.strokeRect(tx+3,ty+3,TILE-6,TILE-6); ctx.restore();
    }

    const board = stations.find(s=>s.type==='board');
    if(board && board.holding){
      const x=board.x+ox, y=board.y+oy, ratio=board.progress||0;
      ctx.save(); ctx.lineWidth=8; ctx.strokeStyle='#3a3c49'; ctx.beginPath(); ctx.arc(x+TILE/2,y+TILE/2,18,0,Math.PI*2); ctx.stroke();
      ctx.strokeStyle='#ffd166'; ctx.beginPath(); ctx.arc(x+TILE/2,y+TILE/2,18,-Math.PI/2,-Math.PI/2+Math.PI*2*ratio); ctx.stroke(); ctx.restore();
      drawItemSprite(board.holding, x+TILE/2, y+14, 0.9);
    }

    const plate = stations.find(s=>s.type==='plate');
    if(plate && plate.plate){ drawItemSprite(plate.plate, plate.x+ox+TILE/2, plate.y+oy+TILE/2, 1); }

    const stove = stations.find(s=>s.type==='stove');
    if(stove && stove.pan && stove.pan.state!=='idle'){
      const x=stove.x+ox, y=stove.y+oy;
      const prog = stove.pan.state==='cooking'? clamp(stove.pan.t/3500,0,1):1;
      bar(x+10,y+TILE-18,TILE-20,10,prog,'#2f3243', stove.pan.state==='burned'?'#ff5a60':stove.pan.state==='cooked'?'#79e08a':'#ffd166');
      const label = stove.pan.state==='cooking' ? 'Cooking' : (stove.pan.state==='cooked' ? 'Ready!' : 'Burned!');
      text(label,x+TILE/2-28,y+8,12, stove.pan.state==='burned'?'#ff5a60':'#fff');
    }
  }
  function drawOrdersTop(){
    const L = 16, T = 10, bubbleW = 220, bubbleH = 78, gap = 10;
    let x = L;
    // helper: fit title
    const fitTextSize = (title, maxW, start=16, min=10)=>{ let s=start; while(s>min && ctx.measureText(title).width > maxW) { s-=1; ctx.font=`700 ${s}px ui-sans-serif,system-ui`; } return s; };

    for(let i=0;i<orders.length;i++){
      const o = orders[i];
      const r = clamp(o.ttl/TUNING.ORDER_TTL, 0, 1);
      rr(x, T, bubbleW, bubbleH, 18, '#2a2c36', '#3a3c49');

      // Title (autoshrink)
      ctx.save(); ctx.fillStyle='#79e08a'; ctx.textAlign='left'; ctx.textBaseline='top';
      ctx.font='700 16px ui-sans-serif,system-ui';
      const size = fitTextSize(o.name, bubbleW-24, 16, 10);
      ctx.font=`700 ${size}px ui-sans-serif,system-ui`;
      ctx.fillText(o.name, x+12, T+8);
      ctx.restore();

      // Ingredient icons row
      const iconsY = T + 32; const cx = x + bubbleW/2; const count = o.need.length;
      const spacing = 28; const totalW = (count-1)*spacing; let ix = cx - totalW/2;
      for(let k=0;k<count;k++){
        // chip background
        rr(ix-14, iconsY-14, 28, 28, 8, '#1f212b');
        // draw item sprite centered in chip
        drawItemSprite(o.need[k]==='Cooked Patty' ? 'Cooked Patty' : (o.need[k]==='Bun' ? 'Bun' : o.need[k]), ix, iconsY, 0.6);
        ix += spacing;
      }

      // Timer bar
      bar(x+12, T + bubbleH - 14, bubbleW-24, 8, r, '#3a3c49', r>.33?'#79e08a':(r>.15?'#ffd166':'#ff5a60'));

      x += bubbleW + gap; if (x + bubbleW > canvas.width - 16) break;
    }
  }
  function drawRoundTimer(){
    const cx = canvas.width/2, cy = 42, R = 26;
    const t = roundMsLeft/ROUND_TOTAL_MS;
    ctx.save();
    ctx.lineWidth = 8; ctx.strokeStyle = '#3a3c49';
    ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2); ctx.stroke();

    const ang = -Math.PI/2 + Math.PI*2 * t;
    let col = '#79e08a'; if(roundMsLeft <= 60000) col = '#ffd166'; if(roundMsLeft <= 20000) col = '#ff5a60';
    ctx.strokeStyle = col; ctx.beginPath(); ctx.arc(cx, cy, R, -Math.PI/2, ang, false); ctx.stroke();

    const secs = Math.ceil(roundMsLeft/1000);
    const mm = Math.floor(secs/60).toString().padStart(1,'0');
    const ss = (secs%60).toString().padStart(2,'0');
    ctx.fillStyle='#eef0f6'; ctx.font='700 14px ui-sans-serif,system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(`${mm}:${ss}`, cx, cy);
    ctx.restore();
  }
  function drawPlayer(){
    const {ox,oy}=origin(); const px=player.x+ox, py=player.y+oy;
    rr(px,py,player.w,player.h,8,'#ffffff');
    ctx.fillStyle='#222'; ctx.fillRect(px+10,py+10,4,4); ctx.fillRect(px+22,py+10,4,4); ctx.fillRect(px+14,py+22,10,3);
    if(player.carrying){ rr(px-8,py-40,64,40,10,'#2a2c36ee','#3a3c49'); drawItemSprite(player.carrying, px+24, py-20, 0.9); }
    if(player.action && player.action.type==='chop'){
      ctx.save(); ctx.lineWidth=8; ctx.strokeStyle='#3a3c49'; ctx.beginPath(); ctx.arc(px+player.w/2,py-40,16,0,Math.PI*2); ctx.stroke();
      ctx.strokeStyle='#ffd166'; ctx.beginPath(); ctx.arc(px+player.w/2,py-40,16,-Math.PI/2,-Math.PI/2 + Math.PI*2*(player.action.progress/(player.action.need||1))); ctx.stroke(); ctx.restore();
    }
  }
  function drawPopups(){
    for(let i=popups.length-1;i>=0;i--){
      const p=popups[i];
      const r = clamp((now()-p.t0)/p.dur,0,1);
      const a = 1-r, dy = r*24, scale = 1 + 0.2*(1-r);
      ctx.save(); ctx.globalAlpha = a; ctx.translate(p.x, p.y - dy); ctx.scale(scale, scale);
      rr(-22,-12,44,24,6,p.color);
      ctx.fillStyle='#0f1720'; ctx.font='800 12px Segoe UI,Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(p.txt, 0, 0); ctx.restore();
      if(r>=1){ popups.splice(i,1); POP_POOL.push(p); }
    }
  }
  function actionButtonRect(){ const w=90,h=90,pad=18; return {x:canvas.width-w-pad,y:canvas.height-h-pad,w,h,r:28}; }
  function drawTouchUI(){
    if(joystick.active){ rr(joystick.baseX-36, joystick.baseY-36, 72, 72, 36, '#00000055', '#00000099'); const kx = joystick.baseX + joystick.vecX * joystick.maxR; const ky = joystick.baseY + joystick.vecY * joystick.maxR; rr(kx-22, ky-22, 44, 44, 22, '#ffffffaa', '#00000099'); }
    else { const bx = 24+52, by = canvas.height-24-52; rr(bx-36, by-36, 72, 72, 36, '#00000033', '#00000055'); }
    const b = actionButtonRect(); rr(b.x, b.y, b.w, b.h, b.r, roundState!=='running' ? '#80838a66' : '#79e08a99', '#75da8599'); ctx.save(); ctx.fillStyle='#0f1720'; ctx.font='800 14px Segoe UI,Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('ACTION', b.x + b.w/2, b.y + b.h/2); ctx.restore();
  }
  function starColor(i){ return (i<=stars)? '#ffd166' : '#5a5d6f'; }
  function hitPlayAgain(x,y){ const btn = {w:200,h:48}; const bx = canvas.width/2 - btn.w/2; const by = canvas.height/2 + 70; return (x>=bx && x<=bx+btn.w && y>=by && y<=by+btn.h); }
  function drawRoundOverOverlay(){
    ctx.save(); ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore();
    const W=420,H=260; const x=canvas.width/2-W/2, y=canvas.height/2-H/2;
    rr(x,y,W,H,16,'#2b2e3c','#434759');
    text('Round Over!', x+24, y+20, 24, '#fff');
    text(`Coins: ${coins}`, x+24, y+64, 18, '#e8e9f1');
    const sx = x+24, sy = y+104;
    for(let i=1;i<=3;i++){
      ctx.save(); ctx.fillStyle = starColor(i);
      ctx.beginPath();
      const cx = sx + (i-1)*60, cy = sy, r=16;
      for(let k=0;k<5;k++){
        const ang = -Math.PI/2 + k*(2*Math.PI/5);
        const ox = cx + Math.cos(ang)*r, oy = cy + Math.sin(ang)*r;
        if(k===0) ctx.moveTo(ox,oy); else ctx.lineTo(ox,oy);
        const ang2 = ang + Math.PI/5;
        ctx.lineTo(cx + Math.cos(ang2)*r*0.5, cy + Math.sin(ang2)*r*0.5);
      }
      ctx.closePath(); ctx.fill(); ctx.restore();
    }
    text(`★ @ ${STAR_1}`, x+24, y+140, 12, '#b7b9c6');
    text(`★★ @ ${STAR_2}`, x+24, y+156, 12, '#b7b9c6');
    text(`★★★ @ ${STAR_3}`, x+24, y+172, 12, '#b7b9c6');
    const btn = {w:200,h:48}; const bx = canvas.width/2 - btn.w/2; const by = canvas.height/2 + 70;
    rr(bx,by,btn.w,btn.h,12,'#79e08a','#3a3c49');
    text('Play Again', bx+btn.w/2, by+14, 18, '#0f1720','center');
    text('(or press R)', bx+btn.w/2, by+30, 12, '#0f1720','center');
  }
  function hint(){
    if(roundState!=='running') return;
    const s=getNearestActionableStation(true);
    if(!s) return;
    let label = '';
    if(s.type==='counterSlot'){
      const item = s.parent.slots[s.i];
      if(!item && player.carrying) label = "Action: Place item";
      else if(item && !player.carrying) label = "Action: Pick up item";
      else if(item && player.carrying && item.kind==='Plate') label = "Action: Add held to plate";
      else if(item && carryingPlate()) label = "Action: Add slot ingredient to your plate";
      else label = "Action: Interact";
    } else {
      const map={
        crateTomato:"Action: Pick Tomato",
        crateLettuce:"Action: Pick Lettuce",
        crateMeat:"Action: Pick Meat",
        crateBun:"Action: Pick/Add Bun",
        board: player.action? "Hold to chop" : (carryingPlate()? "Action: Add chopped to plate":"Action: Place raw / pick chopped"),
        stove: carryingPlate()? "Action: Add cooked patty to plate" : "Action: Add raw meat / take patty",
        plate: "Action: Spawn/pick plate or add to counter plate",
        dropoff:"Action: Drop completed plate",
        trash:"Action: Discard item",
      };
      label = map[s.type] || "Action: Interact";
    }
    ctx.save(); ctx.font='600 14px ui-sans-serif,system-ui,Segoe UI'; const w=Math.max(260, ctx.measureText(label).width+24); ctx.restore();
    rr(24,canvas.height-64,w,36,10,'#2a2c36ee','#3a3c49'); text(label,36,canvas.height-56,14,'#eef0f6');
  }
  function render(alpha){
    ctx.save(); if (SHAKE>0){ ctx.translate(rand(-SHAKE,SHAKE), rand(-SHAKE,SHAKE)); }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // Kitchen backdrop: wall + backsplash + tiled floor
    const grad = ctx.createLinearGradient(0,0,0,canvas.height*0.4);
    grad.addColorStop(0,'#2b2e3a'); grad.addColorStop(1,'#3a3d4c');
    ctx.fillStyle = grad; ctx.fillRect(0,0,canvas.width,canvas.height*0.22);
    ctx.save(); ctx.globalAlpha = 0.25;
    for(let y=8; y<canvas.height*0.22; y+=12){ for(let x=8; x<canvas.width; x+=12){ ctx.fillStyle='#cfd3e2'; ctx.fillRect(x,y,10,10); }}
    ctx.restore();
    const {ox,oy}=origin();
    for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++){
      rr(ox+x*TILE+4, oy+y*TILE+4, TILE-8, TILE-8, 12, (x+y)%2?'#2d3042':'#32354a');
      ctx.save(); ctx.globalAlpha=0.05; ctx.strokeStyle='#000'; ctx.strokeRect(ox+x*TILE+4, oy+y*TILE+4, TILE-8, TILE-8); ctx.restore();
    }
    ctx.fillStyle='rgba(0,0,0,0.15)'; ctx.fillRect(0, oy+TILE*0.9, canvas.width, 6);
    drawStations();
    drawPlayer();
    drawAnims();
    ctx.restore();

    drawOrdersTop();
    drawRoundTimer();

    rr(16, canvas.height-56, canvas.width-32, 40, 12, '#2a2c36aa', '#3a3c49');
    text(`Score: ${score}`, 28, canvas.height-44, 18, '#fff');
    text(`Coins: ${coins}`, 160, canvas.height-42, 14, '#b7b9c6');
    if (combo>1) text(`Combo x${combo}`, 260, canvas.height-42, 14, '#ffd166');

    drawPopups();
    drawTouchUI();
    hint();

    if(roundState==='over') drawRoundOverOverlay();
  }

  // ===== Mouse/touch controls =====
  function actionButtonRect(){ const w=90,h=90,pad=18; return {x:canvas.width-w-pad,y:canvas.height-h-pad,w,h,r:28}; }
  function isInActionButton(x,y){ const b=actionButtonRect(); const cx=b.x+b.w/2, cy=b.y+b.h/2; return Math.hypot(x-cx,y-cy)<=b.w*0.45; }
  function getCanvasCoords(e){ const rect=canvas.getBoundingClientRect(); return {x:(e.clientX-rect.left)*(canvas.width/rect.width), y:(e.clientY-rect.top)*(canvas.height/rect.height)}; }

  canvas.addEventListener('contextmenu', e=>e.preventDefault());
  canvas.addEventListener('pointerdown', e=>{
    const {x,y}=getCanvasCoords(e);
    canvas.setPointerCapture(e.pointerId);

    if(roundState==='over'){
      if(hitPlayAgain(x,y)) reset();
      return;
    }

    const target = getActionableAtScreen(x,y);
    if(target){ tryStartMagnet(target); player._holding = true; interactStart(target); return; }
    if(isInActionButton(x,y)){
      player._holding = true; const t = getNearestActionableStation(true); if(t){ tryStartMagnet(t); interactStart(t); } return;
    }

    joystick.active=true; joystick.id=e.pointerId; joystick.baseX=x; joystick.baseY=y; joystick.curX=x; joystick.curY=y; joystick.vecX=0; joystick.vecY=0;
  });
  canvas.addEventListener('pointermove', e=>{
    if(!joystick.active || joystick.id!==e.pointerId) return;
    const {x,y}=getCanvasCoords(e);
    joystick.curX=x; joystick.curY=y;
    const dx=x-joystick.baseX, dy=y-joystick.baseY; const d = Math.hypot(dx,dy); const r = Math.min(d, joystick.maxR); const ux = dx/(d||1), uy=dy/(d||1);
    joystick.vecX = (r/joystick.maxR)*ux; joystick.vecY = (r/joystick.maxR)*uy;
  });
  function endPointer(e){
    if(joystick.active && (e.pointerId===joystick.id || e.type==='pointercancel')){ joystick.active=false; joystick.id=null; joystick.vecX=joystick.vecY=0; }
    if(player._holding && (e.pointerType==='touch' || e.pointerType==='pen' || e.pointerType==='mouse')){ player._holding=false; player._magnetTarget=null; player._magnetUntil=0; }
    try { canvas.releasePointerCapture(e.pointerId); } catch {}
  }
  canvas.addEventListener('pointerup', endPointer);
  canvas.addEventListener('pointercancel', endPointer);
  canvas.addEventListener('pointerleave', e=>{ if(e.pointerId===joystick.id) endPointer(e); });

  // ===== MAIN GAME LOOP =====
  const MAIN_LOOP_STEP = 1000/60;
  let mainLoopAcc = 0, mainLoopLast = performance.now();
  function tick(){
    const t = performance.now(); let dt = t - mainLoopLast; mainLoopLast = t; if(dt>250) dt=250; mainLoopAcc += dt;
    while(mainLoopAcc >= MAIN_LOOP_STEP){ update(MAIN_LOOP_STEP); mainLoopAcc -= MAIN_LOOP_STEP; }
    render(mainLoopAcc / MAIN_LOOP_STEP); requestAnimationFrame(tick);
  }

  function update(dtMs){
    if (paused) return;

    // Round timer
    if(roundState==='running'){
      roundMsLeft -= dtMs;
      if(roundMsLeft <= 0){
        roundMsLeft = 0; roundState = 'over'; player._holding=false; player._magnetTarget=null; player._magnetUntil=0; player.action=null;
        stars = (coins>=STAR_3)?3:(coins>=STAR_2)?2:(coins>=STAR_1)?1:0;
      }
    }

    const dt = dtMs/1000;

    // movement (keyboard or joystick)
    let mvx=(keys['a']||keys['ArrowLeft']?-1:0)+(keys['d']||keys['ArrowRight']?1:0);
    let mvy=(keys['w']||keys['ArrowUp']?-1:0)+(keys['s']||keys['ArrowDown']?1:0);
    if(joystick.active){ mvx=joystick.vecX; mvy=joystick.vecY; }
    const len=Math.hypot(mvx,mvy)||1; tryMove(mvx/len, mvy/len, dt);

    // magnet pull while holding
    if(player._holding && roundState==='running'){
      const target = player._magnetTarget || getNearestActionableStation(true);
      if(target && canInteract(target)){ if(!player._magnetTarget) tryStartMagnet(target); applyMagnet(dt); }
    }

    // chopping (station-driven, non-stalling)
    const board=stations.find(s=>s.type==='board');
    if(board && board.holding && !board.holding.chopped){
      board.chopT = (board.chopT||0) + dtMs;
      board.progress = clamp((board.chopT)/(board.need||1200), 0, 1);
      if(board.chopT >= (board.need||1200)){
        board.holding.chopped = true; board.progress = 1; spawnAnim('chop', board.x + origin().ox + TILE/2, board.y + origin().oy + TILE/2);
        board.chopActive=false;
      }
    }

    // stove
    const stove=stations.find(s=>s.type==='stove');
    if(stove && stove.pan){
      if(stove.pan.state==='cooking'){ stove.pan.t+=dtMs; if(stove.pan.t>=3500){ stove.pan.state='cooked'; stove.pan.t=0; if(stove.pan.item){stove.pan.item.cooked=true; stove.pan.item.burned=false;} } }
      else if(stove.pan.state==='cooked'){ stove.pan.t+=dtMs; if(stove.pan.t>=4500){ stove.pan.state='burned'; stove.pan.t=0; if(stove.pan.item){stove.pan.item.cooked=false; stove.pan.item.burned=true;} } }
    }

    // orders spawn (rush logic)
    if(roundState==='running'){
      orderTimer += dtMs; const isRush = roundMsLeft <= 90000 || (Math.floor(roundMsLeft/1000)%60 < 20); const curInterval = isRush ? TUNING.ORDER_RUSH_INTERVAL : TUNING.ORDER_INTERVAL_BASE; if(orderTimer>=curInterval){ orderTimer=0; if(orders.length<8) spawnOrder(); }
    }
    // orders ticking + expiry penalty
    for(let i=orders.length-1;i>=0;i--){ orders[i].ttl -= dtMs; if(orders[i].ttl<=0){ orders.splice(i,1); coins = Math.max(0, coins - TUNING.MISS_PENALTY); combo = 0; } }

    if (SHAKE>0) SHAKE -= dt*10;

    // update animations
    updateAnims(dtMs);
  }

  function reset(){
    paused=false; score=0; coins=0; orderTimer=0; popups.length=0; POP_POOL.length=0; orders.length=0; combo=0; lastServeAt=0; anims.length=0;
    roundState='running'; roundMsLeft = ROUND_TOTAL_MS; stars=0;
    player.x=TILE*2; player.y=TILE*5; player.carrying=null; player.action=null; player._holding=false; player._magnetTarget=null; player._magnetUntil=0;
    for(const s of stations){ if(s.type==='board'){s.holding=null;s.progress=0;} if(s.type==='stove'){s.pan=null;} if(s.type==='plate'){s.plate=null;} if(s.type==='counter'){ s.slots = [null,null,null,null,null]; } }
    rebuildSolids(); spawnOrder();
  }

  // === kick off ===
  reset(); requestAnimationFrame(tick);
})();
</script>
</body>
</html>
